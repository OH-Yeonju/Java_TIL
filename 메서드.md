#### 메서드

- 자바에서는 함수를 메서드라고 한다

##### 메서드 정의

```java
public static int add(int a, int b) {
    return a + b;
}
```

메서드는 크게 메서드 선언과 메서드 본문으로 나눌 수 있다.

###### 메서드 선언

```java
public static int add(int a, int b)
```

- 메서드의 선언 부분으로, 메서드 이름, 반환 타입, 매개변수(파라미터) 목록을 포함한다.

- 메서드 선언 정보를 통해 다른 곳에서 해당 메서드를 호출할 수 있다.
  
  - public static
    
    - public : 다른 클래스에서 호출할 수 있는 메서드라는 뜻이다
    
    - static : 객체를 생성하지 않고 호출할 수 있는 정적 메서드라는 뜻이다
  
  - int add(int a, int b)
    
    - int : 반환 타입을 정의한다
    
    - add : 메서드에 이름을 부여한다
    
    - (int a, int b) : 메서드를 호출할 때 전달하는 입력값을 정의한다. 이 변수들은 해당 메서드 안에서만 사용된다. 이렇게 메서드 선언에 사용되는 변수를 영어로 파라미터, 한글로 매개변수라 한다

###### 메서드 본문

- 메서드가 수행해야 하는 코드 블록이다

- 메서드를 호출하면 메서드 본문이 순서대로 실행된다

- 메서드 본문은 블랙박스이다. 메서드를 호출하는 곳에서는 메서드 선언은 알지만 메서드 본문은 모른다

- 메서드의 실행 결과를 반환하려면 return 문을 사용해야 한다.

###### 메서드 호출

- 앞서 정의한 메서드를 호출해서 실행하려면 메서드 이름에 입력 값을 전할하면 된다. 보통 메서드를 호출한다고 표현한다

##### 메서드 호출과 용어정리

- 인수(Argument)
  
  넘기는 값을 영어로 argument, 한글로 인수 또는 인자라 한다

- 매개변수(Parameter)
  
  메서드를 정의할 때 선언한 변수를 매개변수, 파라미터라 한다
  
  메서드를 호출할 때 인수를 넘기면, 그 인수가 매개변수에 대입된다

###### 용어정리

- 인수라는 용어는 '인'과 '수'의 합성어로, 들어가는 수라는 의미를 가진다. 즉, 메서드 내부로 들어가는 값을 의미한다.

- 매개변수는 매개와 변수의 합성어로, 중간에서 전달하는 변수라는 의미를 가진다. 즉, 메서드 호출부와 메서드 내부 사이에서 값을 전달하는 역할을 하는 변수라는 뜻이다

##### 메서드 정의

```java
public static int add(int a, int b) {
    //메서드 본문, 실행 코드
}

제어자 반환타입 메서드이름(매개변수 목록) {
    메서드 본문
}
```

- 제어자 : publicm static과 같은 부분

- 반환타입 : 메서드가 실행된 후 반환하는 데이터의 타입

- 메서드 이름

- 매개변수 : 입력값, optional

- 메서드 본문 : 실제 메서드의 코드가 위치한다. 중괄호 사이에 코드 작성

##### 매개변수가 없거나 반환 타입이 없는 경우

- 매개변수가 없는 경우
  
  - 선언 : public static void printHeader()와 같이 매개변수를 비워두고 정의하면 된다
  
  - 호출 : 인수를 비워두고 호출

- 반환 타입이 없는 경우
  
  - 선언 : 반환 타입을 void로 정의하면 된다
  
  - 호출 : 반환 타입이 없으므로 호출만 하고 반환 값을 받지 않으면 된다

- void와 return 생략
  
  모든 메서드는 항상 return을 호출해야 한다. 그런데 반환 타입 void의 경우에는 예외로 생략해도 된다. 반환 타입이 없는 경우 return 마지막줄에 넣어줌. return을 만나면 해당 메서드는 종료된다

##### 반환 타입

- 반환 타입이 있으면 반드시 값을 반환해야 한다

##### 메서드 호출과 값 전달

***자바는 항상 변수의 값을 복사해서 대입한다***

```java
package method;

public class MethodValue0 {
    public static void main(String[] args) {
        int num1 = 5;
        int num2 = num1;
        num2 = 10;

        System.out.println(num1); // 5
        System.out.println(num2); // 10
    }
}
```

여기서 값을 복사해서 대입한다는 부분이 바로 이 부분이다

```java
int num2 = num1
```

- 이 부분은 생각해보면 num1에 있는 값 5를 복사해서 num2에 넣는 것이다
  
  - 복사한다고 표현한 이유는 num1의 값을 읽어도 num1에 있는 기존 값이 유지되고, 새로운 값이 num2에 들어가기 때문이다.

##### 메서드 호출과 값 반환받기

메서드를 사용해서 값을 변경하려면 어떻게 해야할까?

-> 메서드의 호출 결과를 반환받아서 사용하면 된다 

##### 메서드와 형변환

###### 명시적 형변환

```java
package method;

public class MethodCasting {
    public static void main(String[] args) {
        double number = 1.5;
        // printNumber(number); // java: incompatible types: possible lossy conversion from double to int
        printNumber((int) number); // 명시적 형변환을 사용해 double을 int로 변환
    }

    public static void printNumber(int n) {
        System.out.println("숫자 : " + n);
    }
}
```

##### 자동 형변환

int < double < long

```java
package method;

public class MethodCasting2 {
    public static void main(String[] args) {
        int number = 100;
        printNumber(number); // int에서 double로 자동 형변환
    }

    public static void printNumber(double n) {
        System.out.println("숫자 : " + n);
    }
}
```

##### 메서드 오버로딩

```java
add(int a, int b)
add(int a, int b, int c)
add(double a, double b)
```

- 이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩이라고 한다.

###### 오버로딩 규칙

- 메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩을 할 수 있다. 참고로 반환 타입은 인정하지 않는다

###### 용어 : 메서드 시그니처

- 메서드 시그니처 = 메서드 이름 + 매개변수 타입(순서)
  
  메서드 시그니처는 자바에서 메서드를 구분할 수 있는 고유한 식별자나 서명을 뜻한다. 메서드 시그니처는 메서드의 이름과 매개변수 타입(순서 포함)으로 구성되어 있다. 쉽게 이야기해서 메서드를 구분할 수 있는 기준이다. 자바 입장에서는 각각의 메서드를 고유하게 구분할 수 있어야 한다.
  
  따라서 메서드 오버로딩에서 설명한것처럼 메서드 이름이 같아도 메서드 시그니처가 다르면 다른 메서드로 간주한다.

- 정리하면 본인의 타입에 최대한 맞는 메서드를 찾아서 실행하고, 그래도 없으면 형변환 가능한 타입의 메서드를 찾아서 실행한다.



##### 메서드 사용의 장점

- 코드 재사용 : 메서드는 특정 기능을 캡슐화하므로, 필요할 때마다 그 기능을 다시 작성할 필요 없이 해당 메서드를 호출함으로써 코드를 재사용 할 수 있다

- 코드의 가독성 : 이름이 부여된 메서드는 코드가 수행하는 작업을 명확하게 나타내므로, 코드를 읽는 사람에게 추가적인 문맥을 제공한다

- 모듈성 : 큰 프로그램을 작은, 관리 가능한 부분으로 나눌 수 있다. 이는 코드의 가독성을 향상시키고 디버깅을 쉽게 만든다

- 코드 유지 관리 : 문제 발생하거나 업데이트가 필요한 경우 해당 메서드만 수정하면 된다

- 재사용성과 혹장성 : 잘 설계된 메서드는 다른 프로그램이나 프로젝트에서도 재사용할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 확장하는 데 유용하다

- 추상화 : 메서드를 사용하는 곳에서는 메서드의 구현을 몰라도 된다. 프로그램의 다른 부분에서는 복잡한 내부 작업에 대해 알 필요 없이 메서드를 사용할 수 있다.

- 테스트와 디버깅 용이성 : 개별 메서드는 독립적으로 테스트하고 디버그할 수 있다. 이는 코드의 문제를 신속하게 찾고 수정하는 데 도움이 된다.
