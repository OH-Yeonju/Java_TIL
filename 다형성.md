#### 다형성

프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 뜻한다. 보통 하나의 객체는 하나의 타입으로 고정되어 있다. 그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻이다.



**핵심 이론**

- 다형적 참조

- 메서드 오버라이딩



**다형적 참조 : 부모 타입의 변수가 지식 인스턴스 참조**

- 부모 타입의 변수가 자식 인스턴스를 참조한다

- ```java
  Parent poly = new Child();
  ```

- Child 인스턴스를 만들었다. 이 경우 자식 타입인 Child를 생성했기 때문에 메모리 상에 Child와 Parent가 모두 생성된다

- 생성된 참조값을  Parent 타입의 변수인 poly에 담아둔다



**부모는 자식을 담을 수 있다.**

- 부모 타입은 자식 타입을 담을 수 있다.

- Parent poly는 부모 타입이다. new Child()를 통해 생성된 결과는 Child 타입이다. 자바에서 부모 타입은 자식 타입을 담을 수 있다.

- 반대로 자식 타입은 부모 타입을 담을 수 없다. 

- 자식의 기능 호출 불가



##### 다형적 참조

- 부모 타입은 자식 타입을 참조할 수 있다. 만약 손자가 있다면 손자도 그 하위 타입도 참조할 수 있다.



**다형적 참조와 인스턴스 실행**

- poly.parentMethod()를 호출하면 먼저 참조값을 사용해서 인스턴스를 찾는다. 그리고 다음으로 인스턴스 안에서 실행할 타입도 찾아야 한다. poly는 Parent타입이다. 따라서 PArent 클래스부터 시작해서 필요한 기능을 찾는다. 인스턴스의 Parent 클래스에 parentMethod가 있다. 따라서 해당 메서드가 호출된다



**다형적 참조의 한계**

Parent poly = new Child() 이렇게 자식을 참조한 상황에서 poly가 자식 타입인 child에 있는 childMEthod를 호출하면 어떻게 될까?

poly.childMethod를 샐항하면 먼저 참조값을 통해 인스턴스를 찾는다. 그리고 다음으로 인스턴스 안에서 실행할 타입을 찾아야 한다. 호출자인 poly는 Parent 타입이다. 따라서 Parent클래스부터 시작해서 필요한 기능을 찾는다. 그런데 상속 관계는 부모 방향으로 찾아 올라갈 수는 있지만, 자식 방향으로 찾아 내려갈 수는 없다. Parent는 부모 타입이고 상위에 부모가 없다. 따라서 childMethod를 찾을 수 없으므로 컴파일 오류가 발생한다.\



이런 경우 childMethod를 호출하고 싶으면 어떻게 해야할까? 바로 **캐스팅**이 필요하다



##### 다형성과 캐스팅

**다운캐스팅**

호출하는 타입을 자식인 Child 타입으로 변경하면 인스턴스의 Child에 있는 childMethod()를 호출할 수 있다. 하지만 다음과 같은 문제에 봉착한다

**부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없다**

```java
Child child = (Child) poly;
```

(타입)처럼 괄호와 그 사이에 타입을 지정하면 참조 대상을 특정 타입으로 변경할 수 있다. 이렇게 특정 타입으로 변경하는 것을 캐스팅이라 한다. 

참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변한느 것은 아니다. 해당 참조값을 꺼내고 꺼낸 참조값이 Child 타입이 되는 것이다. 따라서 poly의 타입은 Parent로 기존과 같이 유지된다.



##### 캐스팅

- 업캐스팅 : 부모 타입으로 변경

- 다운캐스팅 : 자식 타입으로 변경

캐스팅은 영어 단어 cast에서 유래되었다. 부모 타입을 자식 타입으로 변경하는 것을 다운캐스팅이라 한다. 반대로 부모 타입으로 변경하는 것은 업캐스팅이라 한다.



##### 캐스팅의 종류

일시적으로 다운캐스팅을 해서 인스턴스에 있는 하위 클래스의 기능을 바로 호출할 수 있다.

```java
((Child) poly).childMethod();
```

이 코드를 실행하면 Parent타입을 임시로 Child로 변경한다. 참고로 캐스팅을 한다고 해서 Parent poly의 타입이 변한느 것은 아니다. 해당 참조값을 꺼내고 꺼낸 참조값이 Child 타입이 되는 것이다. 따라서 poly 타입은 Parent 그대로 유지된다

이렇게 일시적 다운캐스팅을 사용하면 별도의 변수 없이 인스턴스의 자식 타입의 기능을 사용할 수 있다.



##### 업캐스팅

다운캐스팅과 반대로 현재 타입을 부모 타입으로 변경하는 것을 업캐스팅이라 한다.

업캐스팅은 생략할 수 있다. 다운캐스팅은 생략할 수 없다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한다.



##### 다운캐스팅과 주의점

다운캐스팅은 잘못하면 심각한 런타임 오류가 발생할 수 있다.

```java
Parent parent2 = new Parent();
Child child2 = (Child) parent2; //ClassCastException
child2.childMethod();
```

부모 타입으로 객체를 생성하면 메모리 상에 자식 타입은 전혀 존재하지 않는다. 다음으로 다운캐스팅을 하면 메모리 상에 Child 자체가 존재하지 않기 때문에 Child 자체를 사용할 수 없다.  -> ClassCastException



##### 업캐스팅이 안전하고 다운캐스팅이 위험한 이유

업캐스팅의 경우 객체를 생성하면 해당 타입의 상위 부모 타입이 모두 함께 생성되기 때문에 이런 문제가 절대 발생하지 않는다. 따라서 위로만 타입을 변경하는 업캐스팅은 메모리 상에 인스턴스가 모두 존재하기 때문에 항상 안전하다.

반면에 다운캐스팅의 경우 인스턴스에 존재하지 않는 하위 타입으로 객체를 생성하면 부모 타입은 모두 함께 생성되지만 자식 타입은 생성되지 않는다.



**컴파일 오류 vs 런타임 오류**

컴파일 오류는 변수명 오타, 잘못된 클래스 이름 사용 등 자바 프로그램을 실행하기 전에 발생하는 오류이다. 이런 오류는 IDE에서 즉시 확인할 수 있기 때문에 안전하고 좋은 오류이다

반면에 런타임 오류는 이름 그대로 프로그램이 실행ㅎ되고 있는 시점에 발생하는 오류이다.



##### instanceof

다형성에서 참조형 변수는 이름 그대로 다양한 자식을 대상으로 참조할 수 있다. 그런데 참조하는 대상이 다양하기 때문에 어떤 인스턴스를 참조하고 있는지 확인하려면 instanceof 키워드를 사용해야 한다.

참고로 instanceof 키워드는 오른쪽 대상의 자식 타입을 왼쪽에서 참조하는 경우에도 true를 반환한다. 쉽게 이야기해서 오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 들어갈 수 있는 지 대입해보면 된다.



##### 다형성과 메서드 오버라이딩

메서드 오버라이딩에서 기억해야 할 점은 **오버라이딩된 메서드가 항상 우선권을 가진다**는 점이다. 

**Parent -> Child**

- poly 변수는 Parent 타입이ㅏㄷ. 따라서 poly.value poly.method() 를 호출하면 인스턴스의 Parent 타입에서 기능을 찾아서 실행한다.
  
  - poly.value : Parent 타입에 있는 value 값을 읽는다
  
  - poly.method : Parent 타입에 있는 method()를 실행하려고 한다. 그런데 하위 타입인 Child.method()가 오버라이딩 되어 있다. 오버라이딩 된 메서드는 항상 우선권을 가진다.따라서 Child.method()가 실행된다.

더 하위 자식의 오버라이딩 된 메서드가 우선권을 가지는 것이다.


