#### 상속

상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해준다. 이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것이다. 상속을 사용하려면  extends 키워드를 사용하면 된다. 그리고 extends 대상은 하나만 선택할 수 있다.



- 부모 클래스 (슈퍼 클래스) : 상속을 통해 자신의 필드오 ㅏ메서드를 다른 클래스에 제공하는 클래스

- 자식 클래스 (서브 클래스) : 부모 클래스로부터 필드와 메서드를 상속받는 클래스



부모 클래스는 자식 클래스에 접근할 수 없다. 



##### 단일 상속

자바는 다중 상속을 지원하지 않는다. 그래서 extend대상은 하나만 선택할 수 있다. 부모를 하나만 선택할 수 있다는 뜻이다..

다중 상속을 사용하게 되면 다이아몬드 문제가 생길 수 있다. 또한 클래스 계층 구조가 매우 복잡해질 수 있다. 이런 문제점 때문에 자바는 클래스의 다중상속을 허용하지 않는다. 대신에 인터페이스의 다중 구현을 허용해서 이러한 문제를 피한다



##### 상속과 메모리 구조

```java
ElectricCar electricCar = new ElectricCar();
```

new ElectricCar를 호출하면 ElectricCar 뿐만 아니라 상속 관계에 있는 Car까지 함께 포함해서 인스턴스를 생성한다. 참조값은 x001로 하나이지만 실제로 그 안에서는 Car, ElectricCar라는 두가지 클래스 정보가 공존하는 것이다.

상속이라고 해서 단순하게 부모의 필드오 ㅏ메서드만 물려받는게 아니다. 상속 관계를 상용하면 부모 클래스도 함께 포함해서 생성된다. 외부에서 볼대는 하나의 인스턴스를 생성하는 것 같지만 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.



```java
electricCar.charge();
```

참조값을 확인해서 x001.charge()를 호출한다. 따라서 x001을 찾아서 charge()를 호출하면되는 것이다. 그런데 상속 관계의 경우에는 내부에 부모와 자식이 모두 존재한다. 이때 부모를 선택할지 아니면 자식을 선택할지 선택해야 한다.

이때는 호출하는 변수의 타입(클래스)를 기준으로 선택한다. electricCar 변수의 타입이 ElectricCar이므로 인스턴스 내부에 같은 타입인 ElectricCar를 통해서 charge()를 호출한다.



```java
electriccar.move();
```

먼저 x001 참조로 이동한다. 내부에는 Car, ElectricCar 두가지 타입이 있다. 이때 호출하는 변수인 electricCar의 타입이 ElectricCar이므로 이 타입을 선택한다.

그런데 ElectricCar에는 move() 메서드가 없다. 상속 관계에서는 자식 타입에 해당 기능이 없으면 부모 타입으로 올라가서 찾는다. 이 경우 부모인 Car로 올라가서 move()를 찾는다. 부모에 move()가 있으므로 부모에 있는 메서드를 호출한다.



만약 부모에서도 해당 기능을 찾지 못하면 더 상위 부모에서 필요한 기능을 찾아본다. 계속 찾아도 없으면 컴파일 오류가 발생한다.



**정리!**

- 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.

- 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.

- 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 찾지 못하면 컴파일 오류가 발생한다.



##### 상속과 기능 추가

공통 기능은 부모에만 추가하면 된다.

- 상속 관계 덕분에 중복은 줄어들고, 새로운 수소차를 편리하게 확장한것을 알 수 있다.



##### 상속과 메서드 오버라이딩

부모에게서 상속 받은 기능을 자식이 재정의 하는 것을 메서드 오버라이딩이라고 한다.



**@Override**

@이 붙은 부분을 애노테이션이라 한다. 애노테이션은 주석과 비슷한데, 프로그램이 읽을 수 있는 특별한 주석이라 생각하면 된다.

이 애노테이션은 사우이 클래스의 메서드를 오버라이드하는 것임을 나타낸다.

오버라이딩 한 메서드 위에 이 애노테이션을 붙여야 한다.

컴파일러는 이 애노테이션을 보고 메서드가 정확히 오버라이드 되었는지 확인한다. 오버라이딩 조건을 만족시키지 않으면 컴파일 에러를 발생시킨다. 따라서 실수로 오버라이딩을 못하는 경우를 방지해준다.



**오버라이딩과 메머리 구조**

1. electriccar.move를 호출한다

2. electriccar의 타입은 Electriccar이다. 따라서 인스턴스 내부의 electriccar 타입에서 시작하낟.

3. 이미 있기 때문에 부모 타입을 찾지 않는다.



##### 오버로딩 vs 오버라이딩

- 메서드 오버로딩 : 메서드 이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩이라고 한다

- 메서드 오버라이딩 : 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미한다. 상속 관계에서 사용한다. 부모의 기능을 자식이 다시 정의하는 것이다.(재정의)



##### 메서드 오버라이딩 조건

- 메서드 이름 : 메서드 이름이 같아야 한다

- 메서드 파라미터 : 파라미터 타입, 순서, 개수가 같아야 한다

- 반환 타입 : 반환 타입이 같아야 한다. 단, 반환 타입이 하위 클래스 타입일 수 있다.

- 접근 제어자 : 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. 예를 들어, 상위 클래스의 메서드가 protected로 선언되어 있으면 하위 클래스에서 이를 public, protected로 오버라이드 할 수 있지만, private또는 default로 오버라이드 할 수 없다.

- 예외 : 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하윝 ㅏ입의 예외는 선언할 수 있다.

- static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다
  
  - static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다
  
  - final 메서드는 재정의를 금지한다.
  
  - private 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오버라이딩 할 수 없다

- 생성자 오버라이딩 : 생성자는 오버라이딩 할 수 없다.



##### 상속과 접근 제어

public 가능

protected 상속 관계여서 가능

default 같은 패키지여야 가능



**접근 제어와 메모리 구조**

본인 타입에 없으면 부모 타입에서 기능을 찾는데, 이때 접근 제어자가 영향을 준다. 왜냐하면 객체 내부에서는 자식과 부모가 구분되어 있기 때문이다. 결국 자식 타입에서 부모 타입의 기능을 호출할 때, 부모 입장에서 보면 외부에서 호출한 것과 같다.



#### super - 부모 참조

부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다. 이때 super 키워드를 사용하면 부모를 참조할 수 있다.



##### super - 생성자

상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.(규칙)

상속 관계에서 부모의 생성자를 호출할 때는 super(...)를 사용하면 된다.

- 상속 관계의 생성자 호출은 결과적으로 부모에서 자식 순서로 실행된다. 따라서 부모의 데이터를 먼저 초기화하고 그 다음에 자식의 데이터를 초기화한다.

- 상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 super(...)를 호출해야 한다. 단, 기본 생성자인 경우 생략할 수 있다.
  
  - 예외로 생성자 첫줄에 this를 호출할 수 있다. 하지만 언젠가는 super(...)를 무조건 호출해줘야 한다


